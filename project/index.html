<!doctype html>
<html>
  <head>
      <!--per ricaricare sempre la pagina da zero e non usare la cache-->
      <META HTTP-EQUIV=”Pragma” CONTENT=”no-cache”>
      <META HTTP-EQUIV=”Cache-Control” CONTENT=”no-cache”>
      <!--per definire la dimensione e posizione dell'elemento canvas;
        se i valori di width ed height impostati qui sono superiori a
        corrispondenti settati in <canvas width= .. height=.. l'immagine
        verra' adattata ingrandendola, mentre se i valori sono inferiori,
        l'immagine verra' adattata rimpicciolendola
      -->

      <!-- <link rel="stylesheet" href="./resources/webgl-tutorials.css"> </link> -->
	  <link rel="stylesheet" href="./resources/myStyle.css"> </link>
          
      <style>
	  body {
			background: #dddddd;
		}
		#mainCanvas {
			margin: 10px;
			padding: 10px;
			background: #ffffff;
			border: thin inset #aaaaaa;
		}
		.container {  /*to manage text on canvas and webgl */
		  position: relative;
		}
		#text {. /*to manage text on canvas and webgl */
		  background-color: transparent;  /* needed because we setcanvas bg color to white */
		  position: absolute;
		  left: 100px;
		  top: 10px;
		  z-index: 10;
		}
		<!-- canvas { -->
			<!-- background-color: #fff; -->
			<!-- border: 2px solid blue; -->
		<!-- } -->
      </style>
   </head>
   
<body>
  <p> </p>
  <button id = "Button1">Increase D</button>
  <button id = "Button2">Decrease D</button>
  <button id = "Button3">Increase Zm</button>
  <button id = "Button4">Decrease Zm</button>
  <button id = "Button5">Increase fov</button>
  <button id = "Button6">Decrease fov</button>
  <p> </p>

<div class="container">
	<canvas width="600" height="600" id="mainCanvas"></canvas>
	<!-- to manage text on canvas and webgl -->
	<canvas width="600" height="150" id="text"></canvas>
	<div id="uiContainer">
	  <div id="ui">
		<div id="cameraSensibility"></div>
	  </div>
	</div>
</div>
	
<div class="radioContainer">
	<ul class="list">
		<li class="list__item">
			<input type="radio" class="radio-btn" name="modalita" id="a-opt" value="scena" onclick="changeMod(this)"/>
			<label for="a-opt" class="label">Modalita' scena</label>
		</li>
		
		<li class="list__item">
			<input type="radio" class="radio-btn" name="modalita" id="b-opt" value="gara" onclick="changeMod(this)"/>
			<label for="b-opt" class="label">Modalita' gara</label>
		</li>
	</ul>
</div>

<script id="vertex-shader" type="not-javascript">
attribute vec3 position;
uniform mat4 Pmatrix;
uniform mat4 Vmatrix;
uniform mat4 Mmatrix;
attribute vec3 color;//the color of the point
varying vec3 vColor;
void main(void) { //pre-built function
  gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);
  vColor=color;
}
</script>

<script id="fragment-shader" type="not-javascript">
precision mediump float;
varying vec3 vColor;
void main(void) {
  gl_FragColor = vec4(vColor, 1.);
}
</script>

<script type="text/javascript" src="resources/webgl-utils.js"></script>
<script type="text/javascript" src="resources/m4.js"></script>
<script type="text/javascript" src="resources/camera-utils.js"></script>
<script type="text/javascript" src="resources/webgl-lessons-ui.js"></script>
<script type="text/javascript" src="resources/subdiv.js"></script>
<script type="text/javascript" src="resources/mesh_utils.js"></script>
<script type="text/javascript" src="resources/glm_light.js"></script>
<script type="text/javascript" src="resources/obj-mesh-loading.js"></script>
<script type="text/javascript" src="resources/jquery-3.5.1.js"></script>
<script type="text/javascript" src="shaders/shaders.js"></script>
<script src="carrera.js"></script>
<script>

function changeMod(radioButton){
	if(radioButton.value == "scena"){
		modalitaGara = false;
		initCamera();
	}
	else
		modalitaGara = true;
}
/***** INIT-CARICAMENTO MESH *****/
function init(){
	mo_matrix = m4.identity();
	/*Carico tutte le mesh della scena in modo asincrono*/

	//Carico la Mesh Carrera
	loadMeshObj(1, ["carreraMesh"], "./data/carreraCenteredNoRuoteTextured.obj", [mo_matrix]);
	//Carico le ruote
	var ruotaAD_mo_matrix = m4.translate(mo_matrix, 0.53, 0.10704, -0.79903);
	var ruotaPD_mo_matrix = m4.translate(mo_matrix, 0.53, 0.11194, 0.69066);
	loadMeshObj(2, ["ruotaADMesh", "ruotaPDMesh"], "./data/ruotaTextured-R.obj", [ruotaAD_mo_matrix, ruotaPD_mo_matrix]);
	
	//Carico la mesh fotocamera
	var fotocamera_mo_matrix = m4.translate(mo_matrix, 0, 0, 0);
	loadMeshObj(1, ["fotocameraMesh"], "./data/fotocamera1.obj", [fotocamera_mo_matrix]);
	
	//Carico la mesh highwaySign
	var highwaySign_mo_matrix = m4.scale(mo_matrix, 0.5, 0.5, 0.5);
	highwaySign_mo_matrix = m4.translate(highwaySign_mo_matrix, 0, H-0.15, -15);	//H è l'altezza del piano stradale
	loadMeshObj(1, ["highwaySignMesh"], "./data/highwaySignTextured.obj", [highwaySign_mo_matrix]);
	//...QUI Carico eventuali altre mesh della scena...
}


//Disegno il piano stradale
function drawFloor()
{
mo_matrix = m4.identity();

gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer3);
gl.vertexAttribPointer(standardProgramLocs._position, 3, gl.FLOAT, false,0,0);
gl.enableVertexAttribArray(standardProgramLocs._position);

gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer3);
gl.vertexAttribPointer(standardProgramLocs._color, 3, gl.FLOAT, false,0,0) ;
gl.enableVertexAttribArray(standardProgramLocs._color);	

//SETUP DEGLI UNIFORM
gl.uniformMatrix4fv(standardProgramLocs._Pmatrix, false, proj_matrix);
gl.uniformMatrix4fv(standardProgramLocs._Vmatrix, false, view_matrix);
gl.uniformMatrix4fv(standardProgramLocs._Mmatrix, false, mo_matrix);

gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer3);

gl.drawElements(gl.TRIANGLES, indices_floor.length, gl.UNSIGNED_SHORT, 0);

gl.bindBuffer(gl.ARRAY_BUFFER, null); 
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
}

//definizione parametri iniziali
var aspect;
var zmin = 1;
var zmax = 100;
var fov = 40;

var THETA=degToRad(50), PHI=degToRad(30);
var D = 7;

var drag;

//var mozzo_step=degToRad(15);
//var mozzo = 0;
var mo_matrix, mo_matrix1;

var canvas,gl,textCanvas,ctx;


/*============= Creating a canvas ======================*/ //Creiamo 2 canvas, 1 per il testo e una per la macchina
canvas = document.getElementById('mainCanvas');
gl = canvas.getContext('webgl');
if(!gl){
	alert("Your browser does not support WebGL!");
}
//to manage text on canvas and webgl
// look up the text canvas.
textCanvas = document.getElementById("text");
// make a 2D context for it
ctx = textCanvas.getContext("2d");



//CREATE THE UI
webglLessonsUI.setupSlider("#cameraSensibility", {value: 3, slide: updateCameraSensibility, min: 1, max: 10, step: 1});


/*========== Defining and storing the geometry ==========*/
var vertices=[
-1,-1,-1, 1,-1,-1, 1,1,-1, -1,1,-1,
-1,-1,1, 1,-1,1, 1,1,1, -1,1,1,
-1,-1,-1, -1,1,-1, -1,1,1, -1,-1,1,
1,-1,-1, 1,1,-1, 1,1,1, 1,-1,1,
-1,-1,-1, -1,-1,1, 1,-1,1, 1,-1,-1,
-1,1,-1, -1,1,1, 1,1,1, 1,1,-1,];

var colors=[
   0.9,0.9,0.9,  0.9,0.9,0.9,  0.9,0.9,0.9,  0.9,0.9,0.9,
   0.9,0.9,0.9,  0.9,0.9,0.9,  0.9,0.9,0.9,  0.9,0.9,0.9,
   0.9,0.9,0.9,  0.9,0.9,0.9,  0.9,0.9,0.9,  0.9,0.9,0.9,
   0.9,0.9,0.9,  0.9,0.9,0.9,  0.9,0.9,0.9,  0.9,0.9,0.9,
   0.9,0.9,0.9,  0.9,0.9,0.9,  0.9,0.9,0.9,  0.9,0.9,0.9,
   0.9,0.9,0.9,  0.9,0.9,0.9,  0.9,0.9,0.9,  0.9,0.9,0.9,
   ];
var indices = [
0,1,2, 0,2,3, 4,5,6, 4,6,7, 8,9,10, 8,10,11, 12,13,14,
12,14,15, 16,17,18, 16,18,19, 20,21,22, 20,22,23 ];

var vertices2=[
-1,-1,-1, 1,-1,-1, 1,1,-1, -1,1,-1, -1,-1,1, 1,-1,1, 1,1,1, -1,1,1,];
var colors2=[
   0,0,0,  0,0,0,  0,0,0,  0,0,0,
   0,0,0,  0,0,0,  0,0,0,  0,0,0];
var indices2 = [
 0,1, 1,2, 2,3, 3,0, 4,5, 5,6, 6,7, 7,4, 1,5, 2,6, 3,7, 0,4];


/*Definisco la geometria del piano stradale*/
const S=6; // size
const H=-0.15; // altezza
var vertices_floor=[-S,H,-S-100, S,H,-S-100, S,H,S+100, -S,H,S+100];
var colors_floor=[0.7,0.7,0.7,  0.7,0.7,0.7,  0.7,0.7,0.7,  0.7,0.7,0.7];
var indices_floor = [0,1,2, 0,2,3,];



var vertex_buffer3 = gl.createBuffer ();
gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer3);
gl.bufferData(gl.ARRAY_BUFFER,
new Float32Array(vertices_floor), gl.STATIC_DRAW);
// Create and store data into color buffer
var color_buffer3 = gl.createBuffer ();
gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer3);
gl.bufferData(gl.ARRAY_BUFFER,
new Float32Array(colors_floor), gl.STATIC_DRAW);
// Create and store data into index buffer
var index_buffer3= gl.createBuffer ();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer3);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices_floor), gl.STATIC_DRAW);

var vertex_buffer_carrera = gl.createBuffer();
var index_buffer_carrera= gl.createBuffer ();


//usa libreria webgl-utils.js
initPrograms();


function isPowerOf2(value) {
  return (value & (value - 1)) == 0;		//Working with binary arithmetic
}

/******* CARICO LE TEXTURE ********/
// Texture della Fotocamera
var fotocameraTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, fotocameraTexture);
 
// Fill the texture with a 1x1 blue pixel.
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
			  new Uint8Array([0, 0, 255, 255]));

// Asynchronously load an image
var fotocameraTextureImage = new Image();
fotocameraTextureImage.src = "data/fotocameraTexture.jpg";
fotocameraTextureImage.addEventListener('load', function() {
	  // Now that the image has loaded make copy it to the texture.
	  gl.bindTexture(gl.TEXTURE_2D, fotocameraTexture);
	  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, fotocameraTextureImage);
	  gl.generateMipmap(gl.TEXTURE_2D);
	  
	  // Check if the image is a power of 2 in both dimensions.
	  if (isPowerOf2(fotocameraTextureImage.width) && isPowerOf2(fotocameraTextureImage.height)) {
		 // Yes, it's a power of 2. Generate mips.
		 gl.generateMipmap(gl.TEXTURE_2D);
	  } else {
		 // No, it's not a power of 2. Turn off mips and set wrapping to clamp to edge
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	  } 
});

// Texture del cartello stradale
var highwaySignTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, highwaySignTexture);
 
// Fill the texture with a 1x1 blue pixel.
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
			  new Uint8Array([0, 0, 255, 255]));

// Asynchronously load an image
var highwaySignTextureImage = new Image();
highwaySignTextureImage.src = "data/highwaySignTexture.jpg";
highwaySignTextureImage.addEventListener('load', function() {
	  // Now that the image has loaded make copy it to the texture.
	  gl.bindTexture(gl.TEXTURE_2D, highwaySignTexture);
	  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, highwaySignTextureImage);
	  gl.generateMipmap(gl.TEXTURE_2D);
	  
	  // Check if the image is a power of 2 in both dimensions.
	  if (isPowerOf2(highwaySignTextureImage.width) && isPowerOf2(highwaySignTextureImage.height)) {
		 // Yes, it's a power of 2. Generate mips.
		 gl.generateMipmap(gl.TEXTURE_2D);
	  } else {
		 // No, it's not a power of 2. Turn off mips and set wrapping to clamp to edge
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	  } 
});

// Texture della Carrera
var carreraTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, carreraTexture);
 
// Fill the texture with a 1x1 blue pixel.
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
			  new Uint8Array([0, 0, 255, 255]));

// Asynchronously load an image
var carreraTextureImage = new Image();
//carreraTextureImage.src = "data/volpeTexture2.jpg";
carreraTextureImage.src = "data/TextureRuote1.jpg";
carreraTextureImage.addEventListener('load', function() {
	  // Now that the image has loaded make copy it to the texture.
	  gl.bindTexture(gl.TEXTURE_2D, carreraTexture);
	  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, carreraTextureImage);
	  //	gl.generateMipmap(gl.TEXTURE_2D);
	  
	  // Check if the image is a power of 2 in both dimensions.
	  if (isPowerOf2(carreraTextureImage.width) && isPowerOf2(carreraTextureImage.height)) {
		 // Yes, it's a power of 2. Generate mips.
		 gl.generateMipmap(gl.TEXTURE_2D);
	  } else {
		 // No, it's not a power of 2. Turn off mips and set wrapping to clamp to edge
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	  } 
});


/*================= Mouse events ======================*/
var mouseDown=function(e) {
    drag=true;
    old_x=e.pageX, old_y=e.pageY;
    e.preventDefault();
    return false;
};

var mouseUp=function(e){
   drag=false;
};

var mouseMove=function(e) {
if (!drag) return false;
dX=-(e.pageX-old_x)*2*Math.PI/canvas.width;
dY=-(e.pageY-old_y)*2*Math.PI/canvas.height;
//console.log('stampa',dX,dY);
THETA+=dX;
PHI+=dY;
old_x=e.pageX, old_y=e.pageY;
e.preventDefault();
render();
};


document.getElementById("Button1").onclick = function(){D *= 1.1};
document.getElementById("Button2").onclick = function(){D *= 0.9};
document.getElementById("Button3").onclick = function(){zmin  *= 1.1; zmax *= 1.1};
document.getElementById("Button4").onclick = function(){zmin *= 0.9; zmax *= 0.9};
document.getElementById("Button5").onclick = function(){fov  *= 1.1; fov *= 1.1};
document.getElementById("Button6").onclick = function(){fov *= 0.9; fov *= 0.9};

canvas.onmousedown=mouseDown;
canvas.onmouseup=mouseUp;
canvas.mouseout=mouseUp;
canvas.onmousemove=mouseMove;
window.addEventListener('keydown', doKeyDown, true);
window.addEventListener('keyup', doKeyUp, true);

aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;


function degToRad(d) {
   return d * Math.PI / 180;
}

/*=================== Drawing =================== */

/* */
var modalitaGara = false;
/*CAMERA INTERACTION*/
var cameraInteraction = {
	moveForward: false, moveBackward: false, moveLeft: false, moveRight: false, moveUp: false, moveDown: false, rotateRight: false, rotateLeft: false, rotateUp: false, rotateDown: false
}

fineCorsa_inc = 0.6;
var movim_testa = 0.05;
var lastFacingFrame = 0; // the last frame's value of facing
function moveCamera(){
		if (cameraInteraction.moveForward) {
			moveForwardCameraPos(0.01+cameraSensibility);
			moveForwardTarget(0.01+cameraSensibility);
		}
		if (cameraInteraction.moveBackward) {
			moveForwardCameraPos(-0.01-cameraSensibility);
			moveForwardTarget(-0.01-cameraSensibility);
		}
		if (cameraInteraction.moveLeft) {
			moveRightCameraPos(-0.01-cameraSensibility);
			moveRightTarget(-0.01-cameraSensibility);
		}
		if (cameraInteraction.moveRight) {
			moveRightCameraPos(0.01+cameraSensibility);
			moveRightTarget(0.01+cameraSensibility);
		}
		if (cameraInteraction.rotateRight){
			rotateTargetRight(degToRad(-5.5*cameraSensibility-0.5));
		}
		if (cameraInteraction.rotateLeft){
			rotateTargetRight(degToRad(5.5*cameraSensibility+0.5));
		}
		if (cameraInteraction.moveUp){
			moveUpCameraPos(0.005+cameraSensibility);
			moveUpTarget(0.005+cameraSensibility);
		}
		if(cameraInteraction.moveDown){
			moveUpCameraPos(-0.005-cameraSensibility);
			moveUpTarget(-0.005-cameraSensibility);
		}
		if(cameraInteraction.rotateUp){
			rotateTargetUp(degToRad(5.5*cameraSensibility+0.5));
		}
		if(cameraInteraction.rotateDown){
			rotateTargetUp(degToRad(-5.5*cameraSensibility-0.5));
		}
		
		if(modalitaGara){
			if(lancioCarrera == false){	//Qui sto pilotando la carrera, quindi aggiorno il target e la posizione camera in base al movimento della carrera
				//Visuale spingitore
				camera_pos = [px+3.5*Math.sin(degToRad(facing)), 1.5, pz+3.5*Math.cos(degToRad(facing))];		
				target = [px-4*Math.sin(degToRad(facing)), 1.5, pz-4*Math.cos(degToRad(facing))];
				realign();
				//Visuale dall'alto
				<!-- camera_pos = [0, 6, 10]; -->
				<!-- target = [px-4*Math.sin(degToRad(facing)), 3, pz-4*Math.cos(degToRad(facing))]; -->
				<!-- //Simulare il movimento della testa del corridore?! -->
				<!-- if(key[0] == true){ -->
					<!-- if (movim_testa <= 0.05 && movim_testa>-0) -->
						<!-- movim_testa -= 0.01; -->
					<!-- else -->
					<!-- up = [movim_testa, 1, 0]; 	 -->
				<!-- } -->
				<!-- targetAngleUpdate = facing - lastFacingFrame; -->
				<!-- camera_pos = m4.transformPoint(m4.axisRotation([0,1,0], -0.01*facing), camera_pos); -->
				<!-- realign(); -->
				<!-- console.log(camera_pos); -->
				<!-- rotateTargetRight(0.01*facing); -->
				<!-- moveForwardTarget(m4.distance([px,py,pz], [0,0,0]));				 -->
				<!-- moveForwardCameraPos(m4.distance([px,py,pz], [0,0,0])); -->
				<!-- lastFacingFrame = facing; -->
			}else{ //Ho lanciato la macchinina quindi fermo gradualmente la camera (che simula lo spingitore che ha finito di spingere e smette di correre) 
				camera_pos = [camera_pos[0] - fineCorsa_inc*Math.sin(degToRad(facing)), 1.5, camera_pos[2] - fineCorsa_inc*Math.cos(degToRad(facing))];
				fineCorsa_inc *= 0.96;
				target = [px-4*Math.sin(degToRad(facing)), 1.5, pz-4*Math.cos(degToRad(facing))];
			}
		}
}

/*Qui metto il codice che voglio venga eseguito una volta sola quando premo la SpaceBar in modalità gara*/
function lancio(){
	lancioCarrera = true;
	incVelocitaLancio = true;
}

function doKeyDown(e){
         //====================
         // THE W KEY
         //====================
         if (e.keyCode == 87) {
			if(!modalitaGara)
				cameraInteraction.moveForward = true;
			else
				key[0]=true;
		}
		 
         //====================
         // THE S KEY
         //====================
         if (e.keyCode == 83) {
			if(!modalitaGara)
				cameraInteraction.moveBackward = true;
			else
				key[2]=true;
		}
         //====================
         // THE A KEY
         //====================
         if (e.keyCode == 65) {
			if(!modalitaGara)
				cameraInteraction.moveLeft = true;
			else
				key[1]=true;
		}
         //====================
         // THE D KEY
         //====================
         if (e.keyCode == 68) {
			if(!modalitaGara)
				cameraInteraction.moveRight = true;
			else
				key[3]=true;
		}
		// RIGHT ARROW
		if (e.keyCode == 39){
			if(!modalitaGara)
				cameraInteraction.rotateRight = true;
		}
		// LEFT ARROW
		if (e.keyCode == 37){
			if(!modalitaGara)
				cameraInteraction.rotateLeft = true;
		}
		// UP ARROW
		if (e.keyCode == 38){
			if(!modalitaGara)
				cameraInteraction.moveUp = true;
		}
		// DOWN ARROW
		if (e.keyCode == 40){
			if(!modalitaGara)
				cameraInteraction.moveDown = true;
		}
		// NUM 8
		if (e.keyCode == 104){
			if(!modalitaGara)
				cameraInteraction.rotateUp = true;
		}
		// NUM 5
		if (e.keyCode == 101){
			if(!modalitaGara)
				cameraInteraction.rotateDown = true;
		}
		// SPACEBAR
		if (e.keyCode == 32 && modalitaGara){
			lancio();
		}
}


function doKeyUp(e){
         //====================
         // THE W KEY
         //====================
         if (e.keyCode == 87) {
			if(!modalitaGara)
				cameraInteraction.moveForward = false;
			else
				key[0]=false;
		}
         //====================
         // THE S KEY
         //====================
         if (e.keyCode == 83) {
			if(!modalitaGara)
				cameraInteraction.moveBackward = false;
			else
				key[2]=false;
		}
         //====================
         // THE A KEY
         //====================
         if (e.keyCode == 65) {
			if(!modalitaGara)
				cameraInteraction.moveLeft = false;
			else
				key[1]=false;
		}
         //====================
         // THE D KEY
         //====================
         if (e.keyCode == 68) {
			if(!modalitaGara)
				cameraInteraction.moveRight = false;
			else
				key[3]=false;
		}
		// RIGHT ARROW
		if (e.keyCode == 39){
			if(!modalitaGara)
				cameraInteraction.rotateRight = false;
		}
		// LEFT ARROW
		if (e.keyCode == 37){
			if(!modalitaGara)
				cameraInteraction.rotateLeft = false;
		}
		// UP ARROW
		if (e.keyCode == 38){
			if(!modalitaGara)
				cameraInteraction.moveUp = false;
		}
		// DOWN ARROW
		if (e.keyCode == 40){
			if(!modalitaGara)
				cameraInteraction.moveDown = false;
		}
		// NUM 8
		if (e.keyCode == 104){
			if(!modalitaGara)
				cameraInteraction.rotateUp = false;
		}
		// NUM 5
		if (e.keyCode == 101){
			if(!modalitaGara)
				cameraInteraction.rotateDown = false;
		}
}

var cameraSensibility = 0.15;
function updateCameraSensibility(event, ui){
    cameraSensibility = 0.05*ui.value;
}

var proj_matrix, view_matrix;
var render=function() {
	//set projection matrix
	proj_matrix = m4.perspective(degToRad(fov), aspect, zmin, zmax);
	//set view matrix
	moveCamera();
	//var w_pos = [D*Math.sin(PHI)*Math.cos(THETA),
			   //   D*Math.sin(PHI)*Math.sin(THETA),
				  //D*Math.cos(PHI)];
				  
	view_matrix = m4.inverse(m4.lookAt(camera_pos, target, up));

	gl.enable(gl.DEPTH_TEST);
	//gl.enable(gl.CULL_FACE);
	//gl.depthFunc(gl.LEQUAL);
	gl.clearColor(1.0, 1.0, 1.0, 1);	
	<!-- gl.clearColor(0.043, 0.074, 0.376, 1);	 -->
	/*to manage text on canvas and webgl */
	// Clear the 2D canvas
	//to manage text on canvas and webgl
	ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

	gl.clearDepth(1.0);
	gl.viewport(0.0, 0.0, canvas.width, canvas.height);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);


	  //drawAxis(); // disegna assi frame OGGETTO
	  //disegna il cubo base anziche' la macchina
	  //drawCubeWire();

	//  if (!drag)
	//    mozzo-=mozzo_step;

	  //mo_matrix=m4.scale(mo_matrix,0.5,0.5,0.5);

	if(meshes.length >= 1){	//Per ogni oggetto Mesh dentro all'array meshes, lo disegno. NOTA: All'array meshes viene aggiunto un oggetto mesh solo una volta che quest'ultima è stata caricata completamente, correttamente e ha già creato i propri Buffer.	
		for(var i=0; i<meshes.length; i++){
			switch(meshes[i].meshName){
				case "fotocameraMesh":
					gl.useProgram(programList.textureProgram);
					drawFotocameraTexture(meshes[i]);
					break;
				case "highwaySignMesh":
					gl.useProgram(programList.textureProgram);
					drawHighwaySignTexture(meshes[i]);
					break;
				case "carreraMesh":
					gl.useProgram(programList.textureProgram);
					drawCarreraTexture(meshes[i]);
					break;
				case "ruotaADMesh":
				case "ruotaPDMesh":
					gl.useProgram(programList.textureProgram);
					drawRightWheelTexture(meshes[i]);
					break;
				default:
					gl.useProgram(programList.standardProgram);
					drawMesh(meshes[i]);
			}
		}
	}
	gl.useProgram(programList.standardProgram);
	drawFloor(); // disegna il suolo

	//to manage text on canvas and webgl
	  ctx.font = '18pt Calibri';
	  ctx.fillStyle = 'green';
	  ctx.fillText('Welcome to carrera Project', 90, 50);

	// window.requestAnimationFrame(render);
}
// render();

//Per fare una prova di animazione senza andare a tempo, commentare quanto segue
//e scommentare le:
//window.requestAnimationFrame(render);
//
//render()
//
const FRAMES_PER_SECOND = 30;  // Valid values are 60,30,20,15,10...
// set the mim time to render the next frame
const FRAME_MIN_TIME = (1000/60) * (60 / FRAMES_PER_SECOND) - (1000/60) * 0.5;
var lastFrameTime = 0;  // the last frame time

function update(time){
    if(time-lastFrameTime < FRAME_MIN_TIME){ //skip the frame if the call is too early
        //CarDoStep();
		CarreraDoStep();
        window.requestAnimationFrame(update);
        return; // return as there is nothing to do
    }
    lastFrameTime = time; // remember the time of the rendered frame
    // render the frame
    render();
    window.requestAnimationFrame(update); // get next frame
}

init();
initCamera();
CarreraInit();
update(); // start animation
window.requestAnimationFrame(update);

         </script>
   </body>
</html>
