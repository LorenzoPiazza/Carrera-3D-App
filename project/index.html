<!doctype html>
<html>
  <head>
      <!--per ricaricare sempre la pagina da zero e non usare la cache-->
      <META HTTP-EQUIV=”Pragma” CONTENT=”no-cache”>
      <META HTTP-EQUIV=”Cache-Control” CONTENT=”no-cache”>
      <!--per definire la dimensione e posizione dell'elemento canvas;
        se i valori di width ed height impostati qui sono superiori a
        corrispondenti settati in <canvas width= .. height=.. l'immagine
        verra' adattata ingrandendola, mentre se i valori sono inferiori,
        l'immagine verra' adattata rimpicciolendola
      -->

	  <link rel="stylesheet" href="./resources/myStyle.css"> </link>
          
      <style>

		
      </style>
   </head>
   
<body>
	
<div id="mainContainer">	
	<canvas width="900" height="200" id="text">Your browser does not support canvas</canvas>
	<canvas width="1200" height="600" id="mainCanvas"></canvas>
</div>
<div id="touchCanvasContainer">
		<canvas width="200" height="200" id="touchCanvas1"></canvas>
		<canvas width="200" height="200" id="touchCanvas2"></canvas>
</div>

<div id="uiContainer">
		<div class="radioContainer">
			<ul class="list">
				<li class="list__item">
					<input type="radio" class="radio-btn" name="modalita" id="scena" value="scena" checked onclick="changeMod(this)"/>
					<label for="scena" class="label">Modalita' scena</label>
				</li>
				
				<li class="list__item">
					<input type="radio" class="radio-btn" name="modalita" id="gara" value="gara" onclick="changeMod(this)"/>
					<label for="gara" class="label">Modalita' gara</label>
				</li>
			</ul>
			<div id = "sceltaVisuale" hidden>
				<ul class="list">
					<li class="list__item">
						<input type="radio" class="radio-btn" name="visuale" id="spingitore" value="spingitore" checked onclick="changeVisual(this)"/>
						<label for="spingitore" class="label">Visuale spingitore</label>
					</li>
					<li class="list__item">
						<input type="radio" class="radio-btn" name="visuale" id="alto" value="alto" onclick="changeVisual(this)"/>
						<label for="alto" class="label">Visuale dall'alto</label>
					</li>
			</ul>
			</div>
		</div>

		<div id="cameraSensibility"></div>
		<div id="shadowOpt">
			<input type="checkbox" id="shadowCheckBox" name="shadow" value="shadow" onclick="activeShadow(this)">
			<label for="shadowCheckBox">Render con ombre</label>
		</div>

</div>
	

<script type="text/javascript" src="resources/webgl-utils.js"></script>
<script type="text/javascript" src="resources/m4.js"></script>
<script type="text/javascript" src="resources/camera-utils.js"></script>
<script type="text/javascript" src="resources/touchpad.js"></script>
<script type="text/javascript" src="resources/webgl-lessons-ui.js"></script>
<script type="text/javascript" src="resources/subdiv.js"></script>
<script type="text/javascript" src="resources/glm_light.js"></script>
<script type="text/javascript" src="resources/obj-mesh-loading.js"></script>
<script type="text/javascript" src="resources/shadow.js"></script>
<script type="text/javascript" src="resources/jquery-3.5.1.js"></script>
<script type="text/javascript" src="shaders/shaders.js"></script>
<script src="carrera.js"></script>

<script>

function changeMod(radioButton){
	if(radioButton.value == "scena"){
		modalitaGara = false;
		initCamera();
		touchCanvas2.addEventListener("mousedown", doMouseDown); 
		touchCanvas2.addEventListener("mouseup", doMouseUp);
		touchCanvas2.addEventListener("mousemove", doMouseMove2);
		document.getElementById("sceltaVisuale").hidden = true;
		document.getElementById('touchCanvas2').hidden = false;
	}
	else{
		modalitaGara = true;
		//nascondo e disabilito la canvas di rotazione visuale che non serve
		document.getElementById('touchCanvas2').hidden = true;
		touchCanvas2.removeEventListener("mousedown", doMouseDown); 
		touchCanvas2.removeEventListener("mouseup", doMouseUp);
		touchCanvas2.removeEventListener("mousemove", doMouseMove2);
		document.getElementById("sceltaVisuale").hidden = false;
	}
}

var visual = "spingitore";

function changeVisual(radioButton){
	if(radioButton.value == "spingitore")
		visual = "spingitore";
	else
		visual = "alto";
}

var shadowOpt = false;
function activeShadow(checkbox){
	if(checkbox.checked)
		shadowOpt = true;
	else
		shadowOpt = false;

}


var canvas,gl,textCanvas,ctx;



/*============= Creating a canvas ======================*/ //Creiamo 2 canvas, 1 per il testo e una per la macchina
canvas = document.getElementById('mainCanvas');
gl = canvas.getContext('webgl');
if(!gl){
	alert("Your browser does not support WebGL!");
}

//to manage text on canvas and webgl
// look up the text canvas.
textCanvas = document.getElementById("text");
// make a 2D context for it
ctx = textCanvas.getContext("2d");



//Creo le 2 canvas per la gestione del touch*/
var touchCanvas1 = document.getElementById('touchCanvas1');
var ctxTouchCanvas1 = touchCanvas1.getContext("2d");
touchCanvas1.width = 200;
touchCanvas1.height = 200;
ctxTouchCanvas1.globalAlpha = 0.4;
ctxTouchCanvas1.fillStyle = "grey";

var touchCanvas2 = document.getElementById('touchCanvas2');
var ctxTouchCanvas2 = touchCanvas2.getContext("2d");
touchCanvas2.width = 200;
touchCanvas2.height = 200;
ctxTouchCanvas2.globalAlpha = 0.4;
ctxTouchCanvas2.fillStyle = "grey";

// Create an image object. This is not attached to the DOM and is not part of the page.
var cursorImg = new Image();
      cursorImg.onload = function() {
         ctxTouchCanvas1.drawImage(cursorImg, -5, -5, 200, 200);
		 ctxTouchCanvas2.drawImage(cursorImg, -5, -5, 200, 200);
     };
// Now set the source of the image that we want to load
cursorImg.src = "./data/controller.png";
	  
//Variabili necessarie per il disegno ombre
var shadow_frame_buffer, lightViewMatrix;

 

//CREATE THE cameraSensibility setUp slider
webglLessonsUI.setupSlider("#cameraSensibility", {value: 3, slide: updateCameraSensibility, min: 1, max: 10, step: 1});

/******* CARICAMENTO DELLE IMMAGINI E CREAZIONE DELLE TEXTURE ********/
function isPowerOf2(value) {
  return (value & (value - 1)) == 0;		//Working with binary arithmetic
}

function loadImageAndCreateTexture(imageSrc){
	var texture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, texture);
	 
	// Fill the texture with a 1x1 blue pixel.
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
				  new Uint8Array([0, 0, 255, 255]));

	// Asynchronously load an image
	var textureImage = new Image();
	textureImage.src = imageSrc;
	textureImage.addEventListener('load', function() {
		  // Now that the image has loaded make copy it to the texture.
		  gl.bindTexture(gl.TEXTURE_2D, texture);
		  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, textureImage);
		  
		  // Check if the image is a power of 2 in both dimensions.
		  if (isPowerOf2(textureImage.width) && isPowerOf2(textureImage.height)) {
			 // Yes, it's a power of 2. Generate mips.
			 gl.generateMipmap(gl.TEXTURE_2D);
		  } else {
			 // No, it's not a power of 2. Turn off mips and set wrapping to clamp to edge
			 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		  } 
	});
	return texture;
}

// Texture della Fotocamera
var fotocameraTexture = loadImageAndCreateTexture("data/fotocameraTexture.jpg");
// Texture dei cartelli stradali laterali
var highwayLateralSignTexture = loadImageAndCreateTexture("data/highwaySignTexture.jpg");
// Texture del cartello stradale centrale
var highwayCentralSignTexture = loadImageAndCreateTexture("data/highwaySignTexture2.jpg");
// Texture della Carrera
var carreraTexture = loadImageAndCreateTexture("data/VolpeTexture3.jpg");
// Texture delle ruote
var ruotaTexture = loadImageAndCreateTexture("data/TextureRuote.jpg");
// Texture della strada
var stradaTexture = loadImageAndCreateTexture("data/stradaTexture2.jpg");

/******* Variabili relative alla luce *******/
var initial_LightPos = [17, 15, 17];
var lightPos = initial_LightPos;
var ambientLight = 0.6;
var diffuseLight = 0.8;
var specularLight = 0.9;
/******* Creo i materiali ********/
var defaultMaterial = {
	name: "default",
	ka: [0.65, 0.65, 0.65],
	kd: [0.7, 0.7, 0.7],
	ks: [0.180000, 0.180000, 0.180000],
	shininessVal: 10.117647
};
var carMaterial = {
	name: "carMaterial",
	ka: [0.65, 0.65, 0.65],
	kd: [0.7, 0.7, 0.7],
	ks: [0.750000, 0.750000, 0.980000],
	shininessVal: 10.117647
};

var rubyMaterial = {
	name: "rubyMaterial",
	ka: [0.1745, 0.01175, 0.01175],
	kd: [0.61424, 0.04136, 0.04136],
	ks: [0.327811, 0.226959, 0.226959],
	shininessVal: 28
};	
	
var sunMaterial = {
	name: "sunMaterial",
	ka: [1, 1, 0],
	kd: [0.9, 0.9, 0],
	ks: [1, 1, 0],
	shininessVal: 1
};	

var roadMaterial = {
	name: "roadMaterial",
	ka: [0.45, 0.35, 0.35],
	kd: [0.4, 0.4, 0.4],
	ks: [0.474597, 0.474597, 0.474597],
	shininessVal: 50.078431
};	


var fotocameraMeshPos = [-4, 1.5, -7];

/***** INIT-CARICAMENTO MESH *****/
function init(){
	mo_matrix = m4.identity();
	/*Carico tutte le mesh della scena in modo asincrono*/

	//Carico la Mesh Carrera
	loadMeshObj(1, ["carreraMesh"], "./data/carreraCenteredNoRuoteTextured.obj", [mo_matrix], carMaterial, carreraTexture);
	//Carico le ruote
	var ruotaAD_mo_matrix = m4.translate(mo_matrix, 0.53, 0.10704, -0.79903);
	var ruotaPD_mo_matrix = m4.translate(mo_matrix, 0.53, 0.11194, 0.69066);
	loadMeshObj(2, ["ruotaADMesh", "ruotaPDMesh"], "./data/ruotaBlackTextured-R.obj", [ruotaAD_mo_matrix, ruotaPD_mo_matrix], defaultMaterial, ruotaTexture);
	var ruotaAS_mo_matrix = m4.translate(mo_matrix, -0.53, 0.10704, -0.79903);
	var ruotaPS_mo_matrix = m4.translate(mo_matrix, -0.53, 0.11194, 0.69066);
	loadMeshObj(2, ["ruotaASMesh", "ruotaPSMesh"], "./data/ruotaBlackTextured-L.obj", [ruotaAS_mo_matrix, ruotaPS_mo_matrix], defaultMaterial, ruotaTexture);
	
	//Carico la mesh fotocamera
	var fotocamera_mo_matrix = m4.lookAt(fotocameraMeshPos, [0,0,0], [0,1,0]);
	loadMeshObj(1, ["fotocameraMesh"], "./data/fotocamera1.obj", [fotocamera_mo_matrix], defaultMaterial, fotocameraTexture);
	
	//Carico la mesh highwaySign
	var highwaySign_mo_matrix = m4.translate(mo_matrix, 0, -0.30, -12);
	loadMeshObj(1, ["highwaySignStructure"], "./data/highwaySignStructure.obj", [highwaySign_mo_matrix], defaultMaterial, null);
	loadMeshObj(1, ["centralSignTextured"], "./data/centralSignTextured.obj", [highwaySign_mo_matrix], defaultMaterial, highwayCentralSignTexture);
	loadMeshObj(1, ["lateralSignTextured"], "./data/lateralSignTextured.obj", [highwaySign_mo_matrix], defaultMaterial, highwayLateralSignTexture);
	
	//Carico la mesh Sole
	var sun_mo_matrix = m4.scale(m4.translate(mo_matrix, initial_LightPos[0]+2, initial_LightPos[1]+2, initial_LightPos[2]+2), 3, 3, 3);
	loadMeshObj(1, ["soleMesh"], "./data/sun.obj", [sun_mo_matrix], sunMaterial, null);
	
	//Carico la mesh strada
	var strada_mo_matrix = 	m4.translate(mo_matrix, 0, -0.15, 0);
	loadMeshObj(1, ["stradaMesh"], "./data/strada3.obj", [strada_mo_matrix], roadMaterial, stradaTexture);
	
	loadMeshObj(1, ["pianoMesh"], "./data/plane.obj", [strada_mo_matrix], roadMaterial, null);
	loadMeshObj(1, ["casaMesh"], "./data/casa.obj", [strada_mo_matrix], rubyMaterial, null);
	
	/** Controllo la disponibilità, per la versione di WebGL che sta eseguendo, a fare il render con le ombre **/
	if(isShadowAvailable()){
		shadow_frame_buffer = _createFrameBufferObject(gl, 2048, 2048);
	} else{
		document.getElementById("shadowCheckBox").disabled = true;
	}		
}

//definizione parametri iniziali
var aspect;
var zmin = 1;
var zmax = 200;
var fov = 45;

var mo_matrix, mo_matrix1;


/*========== Defining the WebGL programs ==========*/
initPrograms();


/*================= Mouse events ======================*/



function degToRad(d) {
   return d * Math.PI / 180;
}

/*=================== Drawing =================== */

/* */
var modalitaGara = false;
/*CAMERA INTERACTION*/
var cameraInteraction = {
	moveForward: false, moveBackward: false, moveLeft: false, moveRight: false, moveUp: false, moveDown: false, rotateRight: false, rotateLeft: false, rotateUp: false, rotateDown: false
}

fineCorsa_inc = 0.6;
var movim_testa = 0.05;
var lastFacingFrame = 0; // the last frame's value of facing
function moveCamera(){
		if (cameraInteraction.moveForward) {
			moveForwardCameraPos(0.01+cameraSensibility);
			moveForwardTarget(0.01+cameraSensibility);
		}
		if (cameraInteraction.moveBackward) {
			moveForwardCameraPos(-0.01-cameraSensibility);
			moveForwardTarget(-0.01-cameraSensibility);
		}
		if (cameraInteraction.moveLeft) {
			moveRightCameraPos(-0.01-cameraSensibility);
			moveRightTarget(-0.01-cameraSensibility);
		}
		if (cameraInteraction.moveRight) {
			moveRightCameraPos(0.01+cameraSensibility);
			moveRightTarget(0.01+cameraSensibility);
		}
		if (cameraInteraction.rotateRight){
			rotateTargetRight(degToRad(-5.5*cameraSensibility-0.5));
		}
		if (cameraInteraction.rotateLeft){
			rotateTargetRight(degToRad(5.5*cameraSensibility+0.5));
		}
		if (cameraInteraction.moveUp){
			moveUpCameraPos(0.005+cameraSensibility);
			moveUpTarget(0.005+cameraSensibility);
		}
		if(cameraInteraction.moveDown){
			moveUpCameraPos(-0.005-cameraSensibility);
			moveUpTarget(-0.005-cameraSensibility);
		}
		if(cameraInteraction.rotateUp){
			rotateTargetUp(degToRad(5.5*cameraSensibility+0.5));
		}
		if(cameraInteraction.rotateDown){
			rotateTargetUp(degToRad(-5.5*cameraSensibility-0.5));
		}
		
		if(modalitaGara){
			if(lancioCarrera == false){	//Qui sto pilotando la carrera, quindi aggiorno il target e la posizione camera in base al movimento della carrera
				if(visual == "spingitore"){ //Visuale spingitore
					camera_pos = [px+3.5*Math.sin(degToRad(facing)), 1.5, pz+3.5*Math.cos(degToRad(facing))];		
					target = [px-4*Math.sin(degToRad(facing)), 1.5, pz-4*Math.cos(degToRad(facing))];
					realign();
				}else{	//Visuale dall'alto
					camera_pos = [px+10.5*Math.sin(degToRad(facing)), 3, pz+10.5*Math.cos(degToRad(facing))];
					target = [px-5*Math.sin(degToRad(facing)), 0, pz-5*Math.cos(degToRad(facing))];
					realign();
				}
				<!-- //Simulare il movimento della testa del corridore?! -->
				<!-- if(key[0] == true){ -->
					<!-- if (movim_testa <= 0.05 && movim_testa>-0) -->
						<!-- movim_testa -= 0.01; -->
					<!-- else -->
					<!-- up = [movim_testa, 1, 0]; 	 -->
				<!-- } -->
				<!-- targetAngleUpdate = facing - lastFacingFrame; -->
				<!-- camera_pos = m4.transformPoint(m4.axisRotation([0,1,0], -0.01*facing), camera_pos); -->
				<!-- realign(); -->
				<!-- console.log(camera_pos); -->
				<!-- rotateTargetRight(0.01*facing); -->
				<!-- moveForwardTarget(m4.distance([px,py,pz], [0,0,0]));				 -->
				<!-- moveForwardCameraPos(m4.distance([px,py,pz], [0,0,0])); -->
				<!-- lastFacingFrame = facing; -->
			}else{ //Ho lanciato la macchinina quindi fermo gradualmente la camera (che simula lo spingitore che ha finito di spingere e smette di correre) 
				camera_pos = [camera_pos[0] - fineCorsa_inc*Math.sin(degToRad(facing)), camera_pos[1], camera_pos[2] - fineCorsa_inc*Math.cos(degToRad(facing))];
				fineCorsa_inc *= 0.96;
				target = [px-4*Math.sin(degToRad(facing)), target[1], pz-4*Math.cos(degToRad(facing))];
			}
		}
}

/*Qui metto il codice che voglio venga eseguito una volta sola quando premo la SpaceBar in modalità gara*/
function lancio(){
	console.log("lancio");if(modalitaGara){
	
		lancioCarrera = true;
		incVelocitaLancio = true;
	}
}

function doKeyDown(e){
         //====================
         // THE W KEY
         //====================
         if (e.keyCode == 87) {
			if(!modalitaGara)
				cameraInteraction.moveForward = true;
			else
				key[0]=true;
		}
		 
         //====================
         // THE S KEY
         //====================
         if (e.keyCode == 83) {
			if(!modalitaGara)
				cameraInteraction.moveBackward = true;
			else
				key[2]=true;
		}
         //====================
         // THE A KEY
         //====================
         if (e.keyCode == 65) {
			if(!modalitaGara)
				cameraInteraction.moveLeft = true;
			else
				key[1]=true;
		}
         //====================
         // THE D KEY
         //====================
         if (e.keyCode == 68) {
			if(!modalitaGara)
				cameraInteraction.moveRight = true;
			else
				key[3]=true;
		}
		// RIGHT ARROW
		if (e.keyCode == 39){
			if(!modalitaGara)
				cameraInteraction.rotateRight = true;
		}
		// LEFT ARROW
		if (e.keyCode == 37){
			if(!modalitaGara)
				cameraInteraction.rotateLeft = true;
		}
		// UP ARROW
		if (e.keyCode == 38){
			if(!modalitaGara)
				cameraInteraction.moveUp = true;
		}
		// DOWN ARROW
		if (e.keyCode == 40){
			if(!modalitaGara)
				cameraInteraction.moveDown = true;
		}
		// NUM 8
		if (e.keyCode == 104){
			if(!modalitaGara)
				cameraInteraction.rotateUp = true;
		}
		// NUM 5
		if (e.keyCode == 101){
			if(!modalitaGara)
				cameraInteraction.rotateDown = true;
		}
		// SPACEBAR
		if (e.keyCode == 32 && modalitaGara){
			lancio();
		}
}


function doKeyUp(e){
         //====================
         // THE W KEY
         //====================
         if (e.keyCode == 87) {
			if(!modalitaGara)
				cameraInteraction.moveForward = false;
			else
				key[0]=false;
		}
         //====================
         // THE S KEY
         //====================
         if (e.keyCode == 83) {
			if(!modalitaGara)
				cameraInteraction.moveBackward = false;
			else
				key[2]=false;
		}
         //====================
         // THE A KEY
         //====================
         if (e.keyCode == 65) {
			if(!modalitaGara)
				cameraInteraction.moveLeft = false;
			else
				key[1]=false;
		}
         //====================
         // THE D KEY
         //====================
         if (e.keyCode == 68) {
			if(!modalitaGara)
				cameraInteraction.moveRight = false;
			else
				key[3]=false;
		}
		// RIGHT ARROW
		if (e.keyCode == 39){
			if(!modalitaGara)
				cameraInteraction.rotateRight = false;
		}
		// LEFT ARROW
		if (e.keyCode == 37){
			if(!modalitaGara)
				cameraInteraction.rotateLeft = false;
		}
		// UP ARROW
		if (e.keyCode == 38){
			if(!modalitaGara)
				cameraInteraction.moveUp = false;
		}
		// DOWN ARROW
		if (e.keyCode == 40){
			if(!modalitaGara)
				cameraInteraction.moveDown = false;
		}
		// NUM 8
		if (e.keyCode == 104){
			if(!modalitaGara)
				cameraInteraction.rotateUp = false;
		}
		// NUM 5
		if (e.keyCode == 101){
			if(!modalitaGara)
				cameraInteraction.rotateDown = false;
		}
}

var cameraSensibility = 0.15;
function updateCameraSensibility(event, ui){
    cameraSensibility = 0.05*ui.value;
}

var proj_matrix, view_matrix, lightMmatrix;

var render=function() {
	// ridimensiono la canvas, se serve, per adattarla alla dimensione della finestra browser.
	webglUtils.resizeCanvasToDisplaySize(canvas);
	// setto quindi la viewport alla dimensione della canvas e aggiorno l'aspect
	gl.viewport(0.0, 0.0, canvas.width, canvas.height);
	aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
	
	//set projection matrix
	proj_matrix = m4.perspective(degToRad(fov), aspect, zmin, zmax);
	//set view matrix
	moveCamera();				  
	view_matrix = m4.inverse(m4.lookAt(camera_pos, target, up));

	gl.enable(gl.DEPTH_TEST);
	//gl.enable(gl.CULL_FACE);
	//gl.depthFunc(gl.LEQUAL);
	gl.clearColor(0.8235, 0.9137, 0.9764, 1);	//sky color
	gl.clearDepth(1.0);	//Inizializzo il Depth Buffer
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);		//Pulisco sia il color buffer che il depth buffer

	
	gl.useProgram(programList.lightTextureProgram);
	//SETUP DEGLI UNIFORM costanti nell'uso del programma. Gli uniform infatti sono a livello di programma quindi se non cambiano posso settarli una volta sola.
	gl.uniformMatrix4fv(lightTextureProgramLocs._Pmatrix, false, proj_matrix);
	gl.uniformMatrix4fv(lightTextureProgramLocs._Vmatrix, false, view_matrix);
	//Uniform relativi alla luce: Posso farli anche una sola volta fuori dalla drawLightTextureMesh?
	gl.uniform3fv(lightTextureProgramLocs._lightPos, lightPos);
	gl.uniform1f(lightTextureProgramLocs._ambientLight, ambientLight);
	gl.uniform1f(lightTextureProgramLocs._diffuseLight, diffuseLight);
	gl.uniform1f(lightTextureProgramLocs._specularLight, specularLight);
	if(meshes.length >= 1){	//Per ogni oggetto Mesh dentro all'array meshes, lo disegno. NOTA: All'array meshes viene aggiunto un oggetto mesh solo una volta che quest'ultima è stata caricata completamente, correttamente e ha già creato i propri Buffer.	
		for(var i=0; i<meshes.length; i++){
			drawLightTextureMesh(meshes[i]);
		}
	}

	/*to manage text on canvas and webgl */
	// Clear the 2D canvas
	  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	//to manage text on canvas and webgl
	  ctx.font = '20pt Comic Sans MS';
	  ctx.fillStyle = '#BB4430';
	  ctx.textAlign = "center";
	  ctx.fillText('CARRERA 3D WEB APP', ctx.canvas.width/2, ctx.canvas.height/4);
	

	// window.requestAnimationFrame(render);
}
// render();

//Per fare una prova di animazione senza andare a tempo, commentare quanto segue
//e scommentare le:
//window.requestAnimationFrame(render);
//
//render()
//
const FRAMES_PER_SECOND = 30;  // Valid values are 60,30,20,15,10...
// set the mim time to render the next frame
const FRAME_MIN_TIME = (1000/60) * (60 / FRAMES_PER_SECOND) - (1000/60) * 0.5;
var lastFrameTime = 0;  // the last frame time

function update(time){
    if(time-lastFrameTime < FRAME_MIN_TIME){ //skip the frame if the call is too early		
		lightPos = initial_LightPos;
		if(!modalitaGara){
			//lightMmatrix = m4.yRotation(time*0.0004, lightMmatrix);
			//lightPos = m4.transformPoint(lightMmatrix, lightPos);
		} else{	CarreraDoStep(); }
        window.requestAnimationFrame(update);
        return; // return as there is nothing to do
    }
    lastFrameTime = time; // remember the time of the rendered frame
    // render the frame
	if(shadowOpt){ //Metterci la Shadow Option		
		renderWithShadow();
	}else{
		render();
	}
    window.requestAnimationFrame(update); // get next frame
}

init();
initCamera();
CarreraInit();
update(); // start animation
window.requestAnimationFrame(update);


window.onload = function setListener() {
	touchCanvas1.addEventListener("mousedown", doMouseDown);
	touchCanvas1.addEventListener("mouseup", doMouseUp);
	touchCanvas1.addEventListener("mousemove", doMouseMove1);
	touchCanvas2.addEventListener("mousedown", doMouseDown);
	touchCanvas2.addEventListener("mouseup", doMouseUp);
	touchCanvas2.addEventListener("mousemove", doMouseMove2);
    window.addEventListener("mouseup", doMouseUp);	
	canvas.addEventListener("mousedown", lancio);	
	/**Riassocio gli stessi Listener anche ai relativi eventi touchscreen**/
	touchCanvas1.addEventListener("touchstart", doMouseDown); 	
	touchCanvas1.addEventListener("touchend", doMouseUp);
	touchCanvas1.addEventListener("touchmove", doMouseMove1);
	touchCanvas2.addEventListener("touchstart", doMouseDown); 	
	touchCanvas2.addEventListener("touchend", doMouseUp);
	touchCanvas2.addEventListener("touchmove", doMouseMove2);
	window.addEventListener("touchend", doMouseUp);
	canvas.addEventListener("touchstart", lancio);

	window.addEventListener('keydown', doKeyDown, true);
	window.addEventListener('keyup', doKeyUp, true);
}

         </script>
   </body>
</html>
