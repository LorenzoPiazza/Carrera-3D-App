<!doctype html>
<html>
  <head>
      <!--per ricaricare sempre la pagina da zero e non usare la cache-->
      <META HTTP-EQUIV=”Pragma” CONTENT=”no-cache”>
      <META HTTP-EQUIV=”Cache-Control” CONTENT=”no-cache”>
      <!--per definire la dimensione e posizione dell'elemento canvas;
        se i valori di width ed height impostati qui sono superiori a
        corrispondenti settati in <canvas width= .. height=.. l'immagine
        verra' adattata ingrandendola, mentre se i valori sono inferiori,
        l'immagine verra' adattata rimpicciolendola
      -->

      <!-- <link rel="stylesheet" href="./resources/webgl-tutorials.css"> </link> -->
	  <link rel="stylesheet" href="./resources/myStyle.css"> </link>
          
      <style>
	  body {
			background: #dddddd;
		}
		#mainCanvas {
			margin: 10px;
			padding: 10px;
			width: 100vw;		/*Per visualizzare la mainCanvas al 100% della grandezza dello schermo*/
			height: 100vh;
			display: block;
			background: #ffffff;
			z-index : 1;
		}
		.container {  /*to manage text on canvas and webgl */
		  position: relative;
		  z-index: 2;
		}
		#text {. /*to manage text on canvas and webgl */
		  background-color: transparent;  /* needed because we setcanvas bg color to white */
		  position: absolute;
		  left: 100px;
		  top: 10px;
		  z-index: 10;
		}
		<!-- canvas { -->
			<!-- background-color: #fff; -->
			<!-- border: 2px solid blue; -->
		<!-- } -->
      </style>
   </head>
   
<body>
  <p> </p>
  <button id = "Button1">Increase D</button>
  <button id = "Button2">Decrease D</button>
  <button id = "Button3">Increase Zm</button>
  <button id = "Button4">Decrease Zm</button>
  <button id = "Button5">Increase fov</button>
  <button id = "Button6">Decrease fov</button>
  <p> </p>
	
	<canvas width="600" height="600" id="mainCanvas"></canvas>
<div class="container">	
	<!-- to manage text on canvas and webgl -->
	<canvas width="600" height="200" id="text"></canvas>
	<canvas width="150" height="200" id="touchCanvas1"></canvas>
	<canvas width="150" height="200" id="touchCanvas2"></canvas>
	<div id="uiContainer">
	  <div id="ui">
		<div id="cameraSensibility"></div>
	  </div>
	</div>
	<div class="radioContainer">
		<ul class="list">
			<li class="list__item">
				<input type="radio" class="radio-btn" name="modalita" id="scena" value="scena" checked onclick="changeMod(this)"/>
				<label for="scena" class="label">Modalita' scena</label>
			</li>
			
			<li class="list__item">
				<input type="radio" class="radio-btn" name="modalita" id="gara" value="gara" onclick="changeMod(this)"/>
				<label for="gara" class="label">Modalita' gara</label>
			</li>
		</ul>
		<div id = "sceltaVisuale" hidden>
			<ul class="list">
				<li class="list__item">
					<input type="radio" class="radio-btn" name="visuale" id="spingitore" value="spingitore" checked onclick="changeVisual(this)"/>
					<label for="spingitore" class="label">Visuale spingitore</label>
				</li>
				<li class="list__item">
					<input type="radio" class="radio-btn" name="visuale" id="alto" value="alto" onclick="changeVisual(this)"/>
					<label for="alto" class="label">Visuale dall'alto</label>
				</li>
		</ul>
		</div>
	</div>
</div>
	

<script id="vertex-shader" type="not-javascript">
attribute vec3 position;
uniform mat4 Pmatrix;
uniform mat4 Vmatrix;
uniform mat4 Mmatrix;
attribute vec3 color;//the color of the point
varying vec3 vColor;
void main(void) { //pre-built function
  gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);
  vColor=color;
}
</script>

<script id="fragment-shader" type="not-javascript">
precision mediump float;
varying vec3 vColor;
void main(void) {
  gl_FragColor = vec4(vColor, 1.);
}
</script>

<script type="text/javascript" src="resources/webgl-utils.js"></script>
<script type="text/javascript" src="resources/m4.js"></script>
<script type="text/javascript" src="resources/camera-utils.js"></script>
<script type="text/javascript" src="resources/touchpad.js"></script>
<script type="text/javascript" src="resources/webgl-lessons-ui.js"></script>
<script type="text/javascript" src="resources/subdiv.js"></script>
<script type="text/javascript" src="resources/glm_light.js"></script>
<script type="text/javascript" src="resources/obj-mesh-loading.js"></script>
<script type="text/javascript" src="resources/jquery-3.5.1.js"></script>
<script type="text/javascript" src="shaders/shaders.js"></script>
<script src="carrera.js"></script>

<script>

function changeMod(radioButton){
	if(radioButton.value == "scena"){
		modalitaGara = false;
		initCamera();
		touchCanvas2.addEventListener("mousedown", doMouseDown); 
		touchCanvas2.addEventListener("mouseup", doMouseUp);
		touchCanvas2.addEventListener("mousemove", doMouseMove2);
		document.getElementById("sceltaVisuale").hidden = true;
		document.getElementById('touchCanvas2').hidden = false;
	}
	else{
		modalitaGara = true;
		//nascondo e disabilito la canvas di rotazione visuale che non serve
		document.getElementById('touchCanvas2').hidden = true;
		touchCanvas2.removeEventListener("mousedown", doMouseDown); 
		touchCanvas2.removeEventListener("mouseup", doMouseUp);
		touchCanvas2.removeEventListener("mousemove", doMouseMove2);
		document.getElementById("sceltaVisuale").hidden = false;
	}
}

var visual = "spingitore";

function changeVisual(radioButton){
	if(radioButton.value == "spingitore")
		visual = "spingitore";
	else
		visual = "alto";
}

function isPowerOf2(value) {
  return (value & (value - 1)) == 0;		//Working with binary arithmetic
}


var canvas,gl,textCanvas,ctx;



/*============= Creating a canvas ======================*/ //Creiamo 2 canvas, 1 per il testo e una per la macchina
canvas = document.getElementById('mainCanvas');
gl = canvas.getContext('webgl');
if(!gl){
	alert("Your browser does not support WebGL!");
}
//to manage text on canvas and webgl
// look up the text canvas.
textCanvas = document.getElementById("text");
// make a 2D context for it
ctx = textCanvas.getContext("2d");



//Creo le 2 canvas per la gestione del touch*/
var touchCanvas1 = document.getElementById('touchCanvas1');
var ctxTouchCanvas1 = touchCanvas1.getContext("2d");
touchCanvas1.width = 200;
touchCanvas1.height = 200;
ctxTouchCanvas1.globalAlpha = 0.4;
ctxTouchCanvas1.fillStyle = "grey";

var touchCanvas2 = document.getElementById('touchCanvas2');
var ctxTouchCanvas2 = touchCanvas2.getContext("2d");
touchCanvas2.width = 200;
touchCanvas2.height = 200;
ctxTouchCanvas2.globalAlpha = 0.4;
ctxTouchCanvas2.fillStyle = "grey";

// Create an image object. This is not attached to the DOM and is not part of the page.
var cursorImg = new Image();

      cursorImg.onload = function() {
         ctxTouchCanvas1.drawImage(cursorImg, -5, -5, 200, 200);
		 ctxTouchCanvas2.drawImage(cursorImg, -5, -5, 200, 200);
     };
// Now set the source of the image that we want to load
cursorImg.src = "./data/controller.png";
	  

//CREATE THE UI
webglLessonsUI.setupSlider("#cameraSensibility", {value: 3, slide: updateCameraSensibility, min: 1, max: 10, step: 1});

/******* CARICO LE TEXTURE ********/
// Texture della Fotocamera
var fotocameraTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, fotocameraTexture);
 
// Fill the texture with a 1x1 blue pixel.
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
			  new Uint8Array([0, 0, 255, 255]));

// Asynchronously load an image
var fotocameraTextureImage = new Image();
fotocameraTextureImage.src = "data/fotocameraTexture.jpg";
fotocameraTextureImage.addEventListener('load', function() {
	  // Now that the image has loaded make copy it to the texture.
	  gl.bindTexture(gl.TEXTURE_2D, fotocameraTexture);
	  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, fotocameraTextureImage);
	  gl.generateMipmap(gl.TEXTURE_2D);
	  
	  // Check if the image is a power of 2 in both dimensions.
	  if (isPowerOf2(fotocameraTextureImage.width) && isPowerOf2(fotocameraTextureImage.height)) {
		 // Yes, it's a power of 2. Generate mips.
		 gl.generateMipmap(gl.TEXTURE_2D);
	  } else {
		 // No, it's not a power of 2. Turn off mips and set wrapping to clamp to edge
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	  } 
});

// Texture del cartello stradale
var highwaySignTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, highwaySignTexture);
 
// Fill the texture with a 1x1 blue pixel.
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
			  new Uint8Array([0, 0, 255, 255]));

// Asynchronously load an image
var highwaySignTextureImage = new Image();
highwaySignTextureImage.src = "data/highwaySignTexture.jpg";
highwaySignTextureImage.addEventListener('load', function() {
	  // Now that the image has loaded make copy it to the texture.
	  gl.bindTexture(gl.TEXTURE_2D, highwaySignTexture);
	  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, highwaySignTextureImage);
	  gl.generateMipmap(gl.TEXTURE_2D);
	  
	  // Check if the image is a power of 2 in both dimensions.
	  if (isPowerOf2(highwaySignTextureImage.width) && isPowerOf2(highwaySignTextureImage.height)) {
		 // Yes, it's a power of 2. Generate mips.
		 gl.generateMipmap(gl.TEXTURE_2D);
	  } else {
		 // No, it's not a power of 2. Turn off mips and set wrapping to clamp to edge
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	  } 
});

// Texture della Carrera
var carreraTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, carreraTexture);
 
// Fill the texture with a 1x1 blue pixel.
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
			  new Uint8Array([0, 0, 255, 255]));

// Asynchronously load an image
var carreraTextureImage = new Image();
//carreraTextureImage.src = "data/volpeTexture2.jpg";
carreraTextureImage.src = "data/VolpeTexture3.jpg";
carreraTextureImage.addEventListener('load', function() {
	  // Now that the image has loaded make copy it to the texture.
	  gl.bindTexture(gl.TEXTURE_2D, carreraTexture);
	  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, carreraTextureImage);
	  //	gl.generateMipmap(gl.TEXTURE_2D);
	  
	  // Check if the image is a power of 2 in both dimensions.
	  if (isPowerOf2(carreraTextureImage.width) && isPowerOf2(carreraTextureImage.height)) {
		 // Yes, it's a power of 2. Generate mips.
		 gl.generateMipmap(gl.TEXTURE_2D);
	  } else {
		 // No, it's not a power of 2. Turn off mips and set wrapping to clamp to edge
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	  } 
});

// Texture delle ruote
var ruotaTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, ruotaTexture);
 
// Fill the texture with a 1x1 blue pixel.
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
			  new Uint8Array([0, 0, 255, 255]));

// Asynchronously load an image
var ruotaTextureImage = new Image();
//carreraTextureImage.src = "data/volpeTexture2.jpg";
ruotaTextureImage.src = "data/TextureRuote.jpg";
ruotaTextureImage.addEventListener('load', function() {
	  // Now that the image has loaded make copy it to the texture.
	  gl.bindTexture(gl.TEXTURE_2D, ruotaTexture);
	  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, ruotaTextureImage);
	  //	gl.generateMipmap(gl.TEXTURE_2D);
	  
	  // Check if the image is a power of 2 in both dimensions.
	  if (isPowerOf2(ruotaTextureImage.width) && isPowerOf2(ruotaTextureImage.height)) {
		 // Yes, it's a power of 2. Generate mips.
		 gl.generateMipmap(gl.TEXTURE_2D);
	  } else {
		 // No, it's not a power of 2. Turn off mips and set wrapping to clamp to edge
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	  } 
});

// Texture della strada
var stradaTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, stradaTexture);
 
// Fill the texture with a 1x1 blue pixel.
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
			  new Uint8Array([0, 0, 255, 255]));

// Asynchronously load an image
var stradaTextureImage = new Image();
stradaTextureImage.src = "data/stradaTexture2.jpg";
stradaTextureImage.addEventListener('load', function() {
	  // Now that the image has loaded make copy it to the texture.
	  gl.bindTexture(gl.TEXTURE_2D, stradaTexture);
	  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, stradaTextureImage);
	  gl.generateMipmap(gl.TEXTURE_2D);
	  
	  // Check if the image is a power of 2 in both dimensions.
	  if (isPowerOf2(stradaTextureImage.width) && isPowerOf2(stradaTextureImage.height)) {
		 // Yes, it's a power of 2. Generate mips.
		 gl.generateMipmap(gl.TEXTURE_2D);
	  } else {
		 // No, it's not a power of 2. Turn off mips and set wrapping to clamp to edge
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	  } 
});

/******* Variabili relative alla luce *******/
var initial_LightPos = [5, 1, 0];
var ambientLight = 0.6;
var diffuseLight = 0.9;
var specularLight = 1;	//Luce bianca
/******* Creo i materiali ********/
var defaultMaterial = {
	name: "default",
	ka: [0.8, 0.8, 0.8],
	kd: [1, 1, 1],
	ks: [0.840000, 0.840000, 0.840000],
	shininessVal: 94.117647
};

var rubyMaterial = {
	name: "rubyMaterial",
	ka: [0.1745, 0.01175, 0.01175],
	kd: [0.61424, 0.04136, 0.04136],
	ks: [0.727811, 0.626959, 0.626959],
	shininessVal: 90
};	
	
var sunMaterial = {
	name: "sunMaterial",
	ka: [1, 1, 0],
	kd: [0.5, 0.5, 0.5],
	ks: [0.1, 0.1, 0.1],
	shininessVal: 90
};	

var roadMaterial = {
	name: "roadMaterial",
	ka: [0.25, 0.25, 0.25],
	kd: [0.4, 0.4, 0.4],
	ks: [0.774597, 0.774597, 0.774597],
	shininessVal: 70.078431
};	


var fotocameraMeshPos = [-4, 2, 0];
/***** INIT-CARICAMENTO MESH *****/
function init(){
	mo_matrix = m4.identity();
	/*Carico tutte le mesh della scena in modo asincrono*/

	//Carico la Mesh Carrera
	loadMeshObj(1, ["carreraMesh"], "./data/carreraCenteredNoRuoteTextured.obj", [mo_matrix], defaultMaterial, carreraTexture);
	//Carico le ruote
	var ruotaAD_mo_matrix = m4.translate(mo_matrix, 0.53, 0.10704, -0.79903);
	var ruotaPD_mo_matrix = m4.translate(mo_matrix, 0.53, 0.11194, 0.69066);
	loadMeshObj(2, ["ruotaADMesh", "ruotaPDMesh"], "./data/ruotaBlackTextured-R.obj", [ruotaAD_mo_matrix, ruotaPD_mo_matrix], defaultMaterial, ruotaTexture);
	var ruotaAS_mo_matrix = m4.translate(mo_matrix, -0.53, 0.10704, -0.79903);
	var ruotaPS_mo_matrix = m4.translate(mo_matrix, -0.53, 0.11194, 0.69066);
	loadMeshObj(2, ["ruotaASMesh", "ruotaPSMesh"], "./data/ruotaBlackTextured-L.obj", [ruotaAS_mo_matrix, ruotaPS_mo_matrix], defaultMaterial, ruotaTexture);
	
	//Carico la mesh fotocamera
	var fotocamera_mo_matrix = m4.lookAt(fotocameraMeshPos, [0,0,0], [0,1,0]);
	loadMeshObj(1, ["fotocameraMesh"], "./data/fotocamera1.obj", [fotocamera_mo_matrix], defaultMaterial, fotocameraTexture);
	
	//Carico la mesh highwaySign
	var highwaySign_mo_matrix = m4.scale(mo_matrix, 0.5, 0.5, 0.5);
	highwaySign_mo_matrix = m4.translate(highwaySign_mo_matrix, 0, -0.30, -15);	//H è l'altezza del piano stradale
	loadMeshObj(1, ["highwaySignMesh"], "./data/highwaySignTextured.obj", [highwaySign_mo_matrix], rubyMaterial, highwaySignTexture);
	//...QUI Carico eventuali altre mesh della scena...
	
	//Carico la mesh Sole
	var sun_mo_matrix = m4.translate(mo_matrix, initial_LightPos[0], initial_LightPos[1], initial_LightPos[2]);
	loadMeshObj(1, ["soleMesh"], "./data/sun.obj", [sun_mo_matrix], sunMaterial, null);
	
	//Carico la mesh strada
	var strada_mo_matrix = 	m4.translate(mo_matrix, 0, -0.30, 0);
	loadMeshObj(1, ["stradaMesh"], "./data/strada1.obj", [strada_mo_matrix], roadMaterial, stradaTexture);
}


//definizione parametri iniziali
var aspect;
var zmin = 1;
var zmax = 100;
var fov = 40;

var THETA=degToRad(50), PHI=degToRad(30);
var D = 7;

var drag;

//var mozzo_step=degToRad(15);
//var mozzo = 0;
var mo_matrix, mo_matrix1;


/*========== Defining and storing the geometry ==========*/


//usa libreria webgl-utils.js
initPrograms();




/*================= Mouse events ======================*/
var mouseDown=function(e) {
    drag=true;
    old_x=e.pageX, old_y=e.pageY;
    e.preventDefault();
    return false;
};

var mouseUp=function(e){
   drag=false;
};

var mouseMove=function(e) {
if (!drag) return false;
dX=-(e.pageX-old_x)*2*Math.PI/canvas.width;
dY=-(e.pageY-old_y)*2*Math.PI/canvas.height;
//console.log('stampa',dX,dY);
THETA+=dX;
PHI+=dY;
old_x=e.pageX, old_y=e.pageY;
e.preventDefault();
render();
};


document.getElementById("Button1").onclick = function(){D *= 1.1};
document.getElementById("Button2").onclick = function(){D *= 0.9};
document.getElementById("Button3").onclick = function(){zmin  *= 1.1; zmax *= 1.1};
document.getElementById("Button4").onclick = function(){zmin *= 0.9; zmax *= 0.9};
document.getElementById("Button5").onclick = function(){fov  *= 1.1; fov *= 1.1};
document.getElementById("Button6").onclick = function(){fov *= 0.9; fov *= 0.9};

canvas.onmousedown=mouseDown;
canvas.onmouseup=mouseUp;
canvas.mouseout=mouseUp;
canvas.onmousemove=mouseMove;
window.addEventListener('keydown', doKeyDown, true);
window.addEventListener('keyup', doKeyUp, true);




function degToRad(d) {
   return d * Math.PI / 180;
}

/*=================== Drawing =================== */

/* */
var modalitaGara = false;
/*CAMERA INTERACTION*/
var cameraInteraction = {
	moveForward: false, moveBackward: false, moveLeft: false, moveRight: false, moveUp: false, moveDown: false, rotateRight: false, rotateLeft: false, rotateUp: false, rotateDown: false
}

fineCorsa_inc = 0.6;
var movim_testa = 0.05;
var lastFacingFrame = 0; // the last frame's value of facing
function moveCamera(){
		if (cameraInteraction.moveForward) {
			moveForwardCameraPos(0.01+cameraSensibility);
			moveForwardTarget(0.01+cameraSensibility);
		}
		if (cameraInteraction.moveBackward) {
			moveForwardCameraPos(-0.01-cameraSensibility);
			moveForwardTarget(-0.01-cameraSensibility);
		}
		if (cameraInteraction.moveLeft) {
			moveRightCameraPos(-0.01-cameraSensibility);
			moveRightTarget(-0.01-cameraSensibility);
		}
		if (cameraInteraction.moveRight) {
			moveRightCameraPos(0.01+cameraSensibility);
			moveRightTarget(0.01+cameraSensibility);
		}
		if (cameraInteraction.rotateRight){
			rotateTargetRight(degToRad(-5.5*cameraSensibility-0.5));
		}
		if (cameraInteraction.rotateLeft){
			rotateTargetRight(degToRad(5.5*cameraSensibility+0.5));
		}
		if (cameraInteraction.moveUp){
			moveUpCameraPos(0.005+cameraSensibility);
			moveUpTarget(0.005+cameraSensibility);
		}
		if(cameraInteraction.moveDown){
			moveUpCameraPos(-0.005-cameraSensibility);
			moveUpTarget(-0.005-cameraSensibility);
		}
		if(cameraInteraction.rotateUp){
			rotateTargetUp(degToRad(5.5*cameraSensibility+0.5));
		}
		if(cameraInteraction.rotateDown){
			rotateTargetUp(degToRad(-5.5*cameraSensibility-0.5));
		}
		
		if(modalitaGara){
			if(lancioCarrera == false){	//Qui sto pilotando la carrera, quindi aggiorno il target e la posizione camera in base al movimento della carrera
				if(visual == "spingitore"){ //Visuale spingitore
					camera_pos = [px+3.5*Math.sin(degToRad(facing)), 1.5, pz+3.5*Math.cos(degToRad(facing))];		
					target = [px-4*Math.sin(degToRad(facing)), 1.5, pz-4*Math.cos(degToRad(facing))];
					realign();
				}else{	//Visuale dall'alto
					camera_pos = [px+10.5*Math.sin(degToRad(facing)), 3, pz+10.5*Math.cos(degToRad(facing))];
					target = [px-5*Math.sin(degToRad(facing)), 0, pz-5*Math.cos(degToRad(facing))];
					realign();
				}
				<!-- //Simulare il movimento della testa del corridore?! -->
				<!-- if(key[0] == true){ -->
					<!-- if (movim_testa <= 0.05 && movim_testa>-0) -->
						<!-- movim_testa -= 0.01; -->
					<!-- else -->
					<!-- up = [movim_testa, 1, 0]; 	 -->
				<!-- } -->
				<!-- targetAngleUpdate = facing - lastFacingFrame; -->
				<!-- camera_pos = m4.transformPoint(m4.axisRotation([0,1,0], -0.01*facing), camera_pos); -->
				<!-- realign(); -->
				<!-- console.log(camera_pos); -->
				<!-- rotateTargetRight(0.01*facing); -->
				<!-- moveForwardTarget(m4.distance([px,py,pz], [0,0,0]));				 -->
				<!-- moveForwardCameraPos(m4.distance([px,py,pz], [0,0,0])); -->
				<!-- lastFacingFrame = facing; -->
			}else{ //Ho lanciato la macchinina quindi fermo gradualmente la camera (che simula lo spingitore che ha finito di spingere e smette di correre) 
				camera_pos = [camera_pos[0] - fineCorsa_inc*Math.sin(degToRad(facing)), camera_pos[1], camera_pos[2] - fineCorsa_inc*Math.cos(degToRad(facing))];
				fineCorsa_inc *= 0.96;
				target = [px-4*Math.sin(degToRad(facing)), target[1], pz-4*Math.cos(degToRad(facing))];
			}
		}
}

/*Qui metto il codice che voglio venga eseguito una volta sola quando premo la SpaceBar in modalità gara*/
function lancio(){
	lancioCarrera = true;
	incVelocitaLancio = true;
}

function doKeyDown(e){
         //====================
         // THE W KEY
         //====================
         if (e.keyCode == 87) {
			if(!modalitaGara)
				cameraInteraction.moveForward = true;
			else
				key[0]=true;
		}
		 
         //====================
         // THE S KEY
         //====================
         if (e.keyCode == 83) {
			if(!modalitaGara)
				cameraInteraction.moveBackward = true;
			else
				key[2]=true;
		}
         //====================
         // THE A KEY
         //====================
         if (e.keyCode == 65) {
			if(!modalitaGara)
				cameraInteraction.moveLeft = true;
			else
				key[1]=true;
		}
         //====================
         // THE D KEY
         //====================
         if (e.keyCode == 68) {
			if(!modalitaGara)
				cameraInteraction.moveRight = true;
			else
				key[3]=true;
		}
		// RIGHT ARROW
		if (e.keyCode == 39){
			if(!modalitaGara)
				cameraInteraction.rotateRight = true;
		}
		// LEFT ARROW
		if (e.keyCode == 37){
			if(!modalitaGara)
				cameraInteraction.rotateLeft = true;
		}
		// UP ARROW
		if (e.keyCode == 38){
			if(!modalitaGara)
				cameraInteraction.moveUp = true;
		}
		// DOWN ARROW
		if (e.keyCode == 40){
			if(!modalitaGara)
				cameraInteraction.moveDown = true;
		}
		// NUM 8
		if (e.keyCode == 104){
			if(!modalitaGara)
				cameraInteraction.rotateUp = true;
		}
		// NUM 5
		if (e.keyCode == 101){
			if(!modalitaGara)
				cameraInteraction.rotateDown = true;
		}
		// SPACEBAR
		if (e.keyCode == 32 && modalitaGara){
			lancio();
		}
}


function doKeyUp(e){
         //====================
         // THE W KEY
         //====================
         if (e.keyCode == 87) {
			if(!modalitaGara)
				cameraInteraction.moveForward = false;
			else
				key[0]=false;
		}
         //====================
         // THE S KEY
         //====================
         if (e.keyCode == 83) {
			if(!modalitaGara)
				cameraInteraction.moveBackward = false;
			else
				key[2]=false;
		}
         //====================
         // THE A KEY
         //====================
         if (e.keyCode == 65) {
			if(!modalitaGara)
				cameraInteraction.moveLeft = false;
			else
				key[1]=false;
		}
         //====================
         // THE D KEY
         //====================
         if (e.keyCode == 68) {
			if(!modalitaGara)
				cameraInteraction.moveRight = false;
			else
				key[3]=false;
		}
		// RIGHT ARROW
		if (e.keyCode == 39){
			if(!modalitaGara)
				cameraInteraction.rotateRight = false;
		}
		// LEFT ARROW
		if (e.keyCode == 37){
			if(!modalitaGara)
				cameraInteraction.rotateLeft = false;
		}
		// UP ARROW
		if (e.keyCode == 38){
			if(!modalitaGara)
				cameraInteraction.moveUp = false;
		}
		// DOWN ARROW
		if (e.keyCode == 40){
			if(!modalitaGara)
				cameraInteraction.moveDown = false;
		}
		// NUM 8
		if (e.keyCode == 104){
			if(!modalitaGara)
				cameraInteraction.rotateUp = false;
		}
		// NUM 5
		if (e.keyCode == 101){
			if(!modalitaGara)
				cameraInteraction.rotateDown = false;
		}
}

var cameraSensibility = 0.15;
function updateCameraSensibility(event, ui){
    cameraSensibility = 0.05*ui.value;
}

	console.log(canvas.width, canvas.height)
	console.log(canvas.clientWidth, canvas.clientHeight);
	console.log(gl.drawingBufferWidth, gl.drawingBufferHeight);
var proj_matrix, view_matrix, lightMmatrix;


var render=function() {

	webglUtils.resizeCanvasToDisplaySize(canvas);
	gl.viewport(0.0, 0.0, canvas.width, canvas.height);
	aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
	
	//set projection matrix
	proj_matrix = m4.perspective(degToRad(fov), aspect, zmin, zmax);
	//set view matrix
	moveCamera();

				  
	view_matrix = m4.inverse(m4.lookAt(camera_pos, target, up));

	gl.enable(gl.DEPTH_TEST);
	//gl.enable(gl.CULL_FACE);
	//gl.depthFunc(gl.LEQUAL);
	<!-- gl.clearColor(1.0, 1.0, 1.0, 1);	 -->
	<!-- gl.clearColor(0.043, 0.074, 0.376, 1);	 -->
	gl.clearColor(0.8235, 0.9137, 0.9764, 1);	//sky color
	/*to manage text on canvas and webgl */
	
	// Clear the 2D canvas
	//to manage text on canvas and webgl
	ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	
	
	gl.clearDepth(1.0);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);		//Cancello sia il frame buffer che i depth buffer

	
	if(meshes.length >= 1){	//Per ogni oggetto Mesh dentro all'array meshes, lo disegno. NOTA: All'array meshes viene aggiunto un oggetto mesh solo una volta che quest'ultima è stata caricata completamente, correttamente e ha già creato i propri Buffer.	
		for(var i=0; i<meshes.length; i++){
			<!-- switch(meshes[i].meshName){ -->
				<!-- case "fotocameraMesh": -->
					<!-- gl.useProgram(programList.textureProgram); -->
					<!-- drawFotocameraTexture(meshes[i]); -->
					<!-- break; -->
				<!-- case "highwaySignMesh": -->
					<!-- gl.useProgram(programList.textureProgram); -->
					<!-- drawHighwaySignTexture(meshes[i]); -->
					<!-- break; -->
				<!-- case "carreraMesh": -->
					<!-- gl.useProgram(programList.textureProgram); -->
					<!-- drawCarreraTexture(meshes[i]); -->
					<!-- break; -->
				<!-- case "ruotaADMesh": -->
				<!-- case "ruotaPDMesh": -->
					<!-- gl.useProgram(programList.textureProgram); -->
					<!-- drawRightWheelTexture(meshes[i]); -->
			<!-- break; -->
			<!-- default: -->
			<!-- gl.useProgram(programList.standardProgram); -->
			<!-- drawMesh(meshes[i]); -->
			<!-- } -->
			gl.useProgram(programList.lightTextureProgram);
			drawLightTextureMesh(meshes[i]);
		}
	}

	//to manage text on canvas and webgl
	  ctx.font = '18pt Calibri';
	  ctx.fillStyle = 'green';
	  ctx.fillText('Welcome to carrera Project', 90, 50);
	

	// window.requestAnimationFrame(render);
}
// render();

//Per fare una prova di animazione senza andare a tempo, commentare quanto segue
//e scommentare le:
//window.requestAnimationFrame(render);
//
//render()
//
const FRAMES_PER_SECOND = 30;  // Valid values are 60,30,20,15,10...
// set the mim time to render the next frame
const FRAME_MIN_TIME = (1000/60) * (60 / FRAMES_PER_SECOND) - (1000/60) * 0.5;
var lastFrameTime = 0;  // the last frame time

function update(time){
    if(time-lastFrameTime < FRAME_MIN_TIME){ //skip the frame if the call is too early
		
		lightPos = initial_LightPos;
		if(!modalitaGara){
			lightMmatrix = m4.yRotation(time*0.0008, lightMmatrix);
			lightPos = m4.transformPoint(lightMmatrix, lightPos);
		}
		CarreraDoStep();
        window.requestAnimationFrame(update);
        return; // return as there is nothing to do
    }
    lastFrameTime = time; // remember the time of the rendered frame
    // render the frame
    render();
    window.requestAnimationFrame(update); // get next frame
}

init();
initCamera();
CarreraInit();
update(); // start animation
window.requestAnimationFrame(update);


window.onload = function setListener() {
	touchCanvas1.addEventListener("mousedown", doMouseDown); 
	touchCanvas1.addEventListener("mouseup", doMouseUp);
	touchCanvas1.addEventListener("mousemove", doMouseMove1);
	touchCanvas2.addEventListener("mousedown", doMouseDown); 
	touchCanvas2.addEventListener("mouseup", doMouseUp);
	touchCanvas2.addEventListener("mousemove", doMouseMove2);
    window.addEventListener("mouseup", doMouseUp);
}

         </script>
   </body>
</html>
